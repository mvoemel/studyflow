@startuml

package webserver.http {
    enum HttpMethod {

    }

    interface HttpRequest {

    }

    interface HttpResponse {

    }

    enum HttpStatusCode {

    }

    HttpRequest --> contents.BodyContent
    HttpRequest --> HttpMethod

    HttpResponse --> contents.BodyContent
    HttpResponse --> HttpStatusCode

    HttpRequest --> cookies.CookieContainer
    HttpResponse --> cookies.CookieContainer
}

package webserver.http.pipeline {

    interface PipelineBuilder {
        addProcessor(creatorAction: Function<RequestProcessor, RequestProcessor>)
    }

    interface RequestContext {
    getTarget(): EndpointMetadata
    getRequest(): HttpRequest
    getResponse(): HttpResponse
    setResponse(HttpResponse response): HttpResponse
    }

    interface RequestProcessor {
        process(RequestContext context): HttpResponse
    }

    RequestProcessor --> RequestContext
    PipelineBuilder --> RequestProcessor
}
note bottom of webserver.http.pipeline : Wir kÃ¶nnten auch Filter api verwenden.

package webserver.http.cookies {
    class Cookie {

    }
    
    interface CookieContainer {

    }
    
    enum SameSitePolicy {

    }

    CookieContainer -d-> Cookie
}

package webserver.http.contents {
    interface JsonContent {

    }

    interface TextContent {

    }

    interface BodyContent {

    }

    BodyContent <|-- JsonContent
    BodyContent <|-- TextContent
}

package webserver.controllers {
    interface ControllerRegistry {

    }

    interface ControllerFactory {

    }

    class ControllerMetadata {
        clazz: Class<?>
        route: RestRoute
        endpoints: List<EndpointMetadata>
    }

    class EndpointMetadata {
        route(): RestRoute
    }

    EndpointMetadata --> routing.RestRoute
    ControllerMetadata --> EndpointMetadata
}

package webserver.annotations {
    annotation Endpoint {
        method(): HttpMethod
    }

    annotation Route {
        route(): String
    }
}

package webserver.controllers.routing {
    class RestRoute {
        segments(): List<RouteSegments>
    }

    class RouteSegment {
        type(): SegmentType
        value(): String
        is(type: SegmentType): boolean
    }

    class RouteTrie {

    }

    enum SegmentType {
        STATIC
        CAPTURE
    }

    RouteSegment -d-> SegmentType
    RestRoute -d-> RouteSegment

    RouteTrie --> RouteSegment
    RouteTrie --> EndpointMetadata
}

package webserver.sun {
    class SunHttpWebServer{

    }

    class SunHttpWebServerBuilder {

    }

    class SunHttpRequest {

    }

    class SunHttpResponse {

    }

    class SunRootHttpHandler {

    }

    SunHttpWebServer -d-|> webserver.WebServer
    SunHttpWebServerBuilder -d-|> webserver.WebServerBuilder
    SunHttpWebServerBuilder -d-> SunHttpWebServer
    SunHttpRequest --|> HttpRequest
    SunHttpResponse --|> HttpResponse
}

package webserver {
    interface WebServer {

    }

    interface WebServerBuilder {
        configureControllers(configurationAction: Consumer<ControllerRegistry>): WebServerBuilder
        configurePipeline(configurationAction: Consumer<PipelineBuilder>): WebServerBuilder
    }

    WebServerBuilder --> PipelineBuilder
    WebServerBuilder --> webserver
}

@enduml